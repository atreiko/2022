/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/choreographer-js/dist/Animation.js":
/*!*********************************************************!*\
  !*** ./node_modules/choreographer-js/dist/Animation.js ***!
  \*********************************************************/
/***/ ((module) => {

eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/** The Animation class.\n  *\n  * constructed with the following config object properties:\n    {String} type     | the name of the animation function\n    {Function} fn     | the animation function\n    {Array} range     | either a one- or two-dimensional array of ranges, i.e. [0,5] or [[0,3], [4,5]]\n    NOTE: Bugs will occur if you overlap animation ranges that affect the same style properties!\n\n    [ Only one of the below (selector or selectors) is necessary. If they both exist, 'selectors' will be used. ]\n    {String} selector | a valid DOM Element selector string, ex. '.classname' or '#box .thing[data-attr=true]'\n    {Array} selectors | an array of selector strings (described above).\n\n    {String} style    | a valid CSS style property.\n    NOTE: If you are using 'transform', follow it with a colon and the property name, ex. 'transform:scaleX'\n\n    {Number} from     | The minimum value to set to the style property. Useful when progressively calculating a value.\n    {Number} to       | The value to set to the style property. (Or the max, when progressively calculating a value.)\n    NOTE: If you are ONLY using the 'to' value, like with a 'change' animation, this could also be {String} to.\n\n    {String} unit     | The unit string to append to the value, ex. '%', 'px', 'deg'\n **/\n\nvar Animation = function () {\n  function Animation(config) {\n    _classCallCheck(this, Animation);\n\n    this.config = config;\n    this.storeNodes();\n  }\n\n  // Either use 'selector' or 'selectors' to find and store all the DOM nodes.\n\n\n  _createClass(Animation, [{\n    key: 'storeNodes',\n    value: function storeNodes() {\n      var _this = this;\n\n      if (this.config.selector) {\n\n        if (typeof this.config.selector === 'string') {\n          this.nodes = Array.prototype.slice.call(document.querySelectorAll(this.config.selector));\n        } else if (this.config.selector.length) {\n          this.nodes = Array.prototype.slice.call(this.config.selector);\n        } else {\n          this.nodes = [this.config.selector];\n        }\n      }\n\n      if (this.config.selectors) {\n        this.nodes = [];\n        this.config.selectors.forEach(function (s) {\n\n          if (typeof s === 'string') {\n            var nodes = Array.prototype.slice.call(document.querySelectorAll(s));\n            _this.nodes = _this.nodes.concat(nodes);\n          } else if (_this.config.selector.length) {\n            _this.nodes = _this.nodes.concat(Array.prototype.slice.call(s));\n          } else {\n            _this.nodes = _this.nodes.push(s);\n          }\n        });\n      }\n    }\n\n    // Just a helper to get the relative location of a value within a range.\n    // example: getProgress(1, [0, 2]) = 0.5\n\n  }, {\n    key: 'getProgress',\n    value: function getProgress(val, _ref) {\n      var _ref2 = _slicedToArray(_ref, 2);\n\n      var min = _ref2[0];\n      var max = _ref2[1];\n\n      return (val - min) / (max - min);\n    }\n\n    /** Returns the 'progress' - relative position within the animation range.\n      * @param {Number} position  | passed in value from 'runAt' (below)\n      * @return {Number} progress | the relative location (between 0 and 1 when in range) within a range.\n                                    if there are multiple ranges and the position is not in any of them,\n                                    return -1. Otherwise, return the value (even if out of range).\n     **/\n\n  }, {\n    key: 'getProgressAt',\n    value: function getProgressAt(position) {\n      // If there are multiple ranges, then figure out which one is relevant and\n      // calculate the progress within that one. You can't have multiple active\n      // ranges unless they're overlapping -- in which case it is YOUR bug, dude.\n      if (_typeof(this.config.range[0]) === 'object') {\n\n        var activeRange = void 0;\n\n        // If there's a range that is active, store it!\n        this.config.range.forEach(function (r) {\n          if (isBetween(postion, r[0], r[1])) activeRange = r;\n        });\n\n        if (!activeRange) return -1;else return this.getProgress(position, activeRange);\n      }\n\n      return this.getProgress(position, this.config.range);\n    }\n\n    /** And this is where all of that work ~finally~ pays off!\n      * This runs the animation by getting the relative progress and running accordingly.\n      * @param {Number} position  | the location marker - could be a scroll location, a timestamp, a mouseX position...\n     **/\n\n  }, {\n    key: 'runAt',\n    value: function runAt(position) {\n      var _this2 = this;\n\n      var progress = this.getProgressAt(position);\n\n      // If we are OUT OF RANGE, then we have to do a few extra things.\n      if (progress < 0 || progress > 1) {\n\n        // First, check if any of our nodes were already animated at this same style prop, at this same location.\n        var animated = void 0;\n        this.nodes.forEach(function (node) {\n          if (node.getAttribute('animated').indexOf(_this2.config.style) > -1) animated = true;\n        });\n\n        // If NOT, then you can go ahead and animate it here.\n        // We need this checkpoint to avoid overriding each other.\n\n        // If you're using class instead of style props, it don't matter.\n        if (this.config.style === 'class' || !animated) {\n          // If it's a simple 'change' function, we just need a value outside of 0 to 1. Could be -9.87. Doesn't matter.\n          if (this.config.type === 'change') progress = -1;\n\n          // If it's a 'scale' function, then get the min or max progress.\n          if (this.config.type === 'scale') {\n            if (progress < 0) progress = 0;\n            if (progress > 1) progress = 1;\n          }\n        } else {\n\n          // If we are OUT OF RANGE and some of our nodes are already animated, then get out of here!!!!\n          return;\n        }\n      }\n\n      // OK, finally ready? Run that animation, baby.\n      this.nodes.forEach(function (node) {\n\n        // If in range ---\n        // (Notice that we're NOT doing >= and <= here. This is because if you're on the edges of the\n        // range, you should be able to override this animation with another one.)\n        if (progress > 0 && progress < 1) {\n          node.setAttribute('animated', node.getAttribute('animated') + '|' + _this2.config.style);\n        }\n\n        _this2.config.fn({\n          node: node,\n          style: _this2.config.style,\n          from: _this2.config.from,\n          to: _this2.config.to,\n          unit: _this2.config.unit,\n          progress: progress\n        });\n      });\n    }\n  }]);\n\n  return Animation;\n}();\n\nmodule.exports = Animation;\n\n//# sourceURL=webpack://gulp-2022/./node_modules/choreographer-js/dist/Animation.js?");

/***/ }),

/***/ "./node_modules/choreographer-js/dist/Choreographer.js":
/*!*************************************************************!*\
  !*** ./node_modules/choreographer-js/dist/Choreographer.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Animation = __webpack_require__(/*! ./Animation */ \"./node_modules/choreographer-js/dist/Animation.js\");\nvar defaultAnimations = __webpack_require__(/*! ./defaultAnimations */ \"./node_modules/choreographer-js/dist/defaultAnimations.js\");\n\n// Store a no-op\nvar noop = function noop() {};\n\n/** Choreographer\n  * constructed with a config object with the following keys and values:\n      {Object} customFunctions | [optional] Keys are function names, values are animation functions.\n      {Array} animations       | An array of Animation class config objects.\n **/\n\nvar Choreographer = function () {\n  function Choreographer(config) {\n    var _this = this;\n\n    _classCallCheck(this, Choreographer);\n\n    this.customFunctions = config.customFunctions || {};\n    this.animations = config.animations.map(function (anim) {\n      anim.fn = _this.getAnimationFn(anim.type);\n      return new Animation(anim);\n    });\n  }\n\n  /** Helper to grab a function by its type. First try the defaults, then custom, then no-op.\n    * @param {String} type | the name (or key value) of the animation function.\n   **/\n\n\n  _createClass(Choreographer, [{\n    key: 'getAnimationFn',\n    value: function getAnimationFn(type) {\n      return defaultAnimations[type] || this.customFunctions[type] || noop;\n    }\n\n    /** If you need to update the animation configs at any point.\n      * @param {Array} animations | An array of your new Animation class config objects.\n     **/\n\n  }, {\n    key: 'updateAnimations',\n    value: function updateAnimations(animations) {\n      var _this2 = this;\n\n      // Wipe out the old animations and replace 'em.\n      this.animations = animations.map(function (anim) {\n        anim.fn = _this2.getAnimationFn(anim.type);\n        return new Animation(anim);\n      });\n    }\n\n    /** Run those animations based on a given location!\n      * @param {Number} position | the location marker - could be a scroll location, a timestamp, a mouseX position...\n     **/\n\n  }, {\n    key: 'runAnimationsAt',\n    value: function runAnimationsAt(position) {\n\n      // Clear all the nodes' 'animated' attribute.\n      this.animations.forEach(function (anim) {\n        anim.nodes.forEach(function (node) {\n          return node.setAttribute('animated', '');\n        });\n      });\n\n      // Run and done.\n      this.animations.forEach(function (anim) {\n        return anim.runAt(position);\n      });\n    }\n  }]);\n\n  return Choreographer;\n}();\n\nmodule.exports = Choreographer;\n\n//# sourceURL=webpack://gulp-2022/./node_modules/choreographer-js/dist/Choreographer.js?");

/***/ }),

/***/ "./node_modules/choreographer-js/dist/defaultAnimations.js":
/*!*****************************************************************!*\
  !*** ./node_modules/choreographer-js/dist/defaultAnimations.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar getInjectedTransformString = __webpack_require__(/*! ./getInjectedTransformString */ \"./node_modules/choreographer-js/dist/getInjectedTransformString.js\");\n\n/** @method scale\n  * [built-in animation function]\n  * Based on the data provided, your node will receive an updated, scaled style value.\n  *\n  * @param {Object} data : {\n  *          {Node} node       | the node you want to modify\n  *          {String} style    | the style property you want to modify\n  *          {Number} from     | minimum value\n  *          {Number} to       | maximum value\n  *          {Number} progress | a value between 0 and 1; the proportion of value we should use\n  *          {String} unit     | optional - unit value, e.g. 'px' or '%'\n  *        }\n **/\nvar scale = function scale(data) {\n  // Get the relative value (proportional to the min-max range you gave.)\n  var scaledValue = (data.to - data.from) * data.progress + data.from;\n  // Stick on the unit, if there is one.\n  var scaledValueString = data.unit ? scaledValue + data.unit : scaledValue;\n\n  // If it's a regular old style property, just replace the value. No fuss.\n  if (data.style.split(':').length === 1) {\n    data.node.style[data.style] = scaledValueString;\n    return;\n  }\n\n  /*~~ If the style is a CSS transform, we gotta do some funky shit. ~~*/\n  var transformProp = data.style.split(':')[1];\n  data.node.style.transform = getInjectedTransformString(data.node, transformProp, scaledValueString);\n};\n\n/** @method change\n  * [built-in animation function]\n  * Based on the data provided, your node will have the style value assigned or remok\n  * @param {Object} data : {\n  *          {Node} node       | the node you want to modify\n  *          {String} style    | the style property you want to modify\n  *          {Value} to        | the style value (number, string -- whatever valid type this CSS prop takes)\n  *          {Number} progress | a value between 0 and 1; the proportion of value we should use\n  *        }\n **/\nvar change = function change(data) {\n  var newValue = data.progress < 0 ? null : data.to;\n  var newValueString = newValue && data.unit ? newValue + data.unit : newValue;\n\n  // If the progress is less than 0, we just need to nullify this style value.\n  // But, if the style prop is 'transition', apply it only after the last transition ends.\n  if (data.progress < 0 && data.style === 'transition') {\n    data.node.addEventListener('transitionend', function (e) {\n      if (e.target === data.node) data.node.style[data.style] = null;\n    });\n    return;\n  }\n\n  // If it's a regular old style property, just replace the value. No fuss.\n  if (data.style.split(':').length === 1) {\n    if (data.style === 'class') {\n      data.node.classList[newValue ? 'add' : 'remove'](data.to);\n      return;\n    }\n\n    data.node.style[data.style] = newValueString;\n    return;\n  }\n\n  /*~~ If the style is a CSS transform, we gotta do some funky shit. ~~*/\n  var transformProp = data.style.split(':')[1];\n  data.node.style.transform = getInjectedTransformString(data.node, transformProp, newValueString);\n};\n\nmodule.exports = { scale: scale, change: change };\n\n//# sourceURL=webpack://gulp-2022/./node_modules/choreographer-js/dist/defaultAnimations.js?");

/***/ }),

/***/ "./node_modules/choreographer-js/dist/getInjectedTransformString.js":
/*!**************************************************************************!*\
  !*** ./node_modules/choreographer-js/dist/getInjectedTransformString.js ***!
  \**************************************************************************/
/***/ ((module) => {

eval("\n\nvar translations = {\n  translateX: 0,\n  translateY: 1,\n  translateZ: 2\n};\n\nvar scales = {\n  scaleX: 0,\n  scaleY: 1,\n  scaleZ: 2\n};\n\nvar transformKeys = {\n  'transform': 'transform',\n  'webkitTransform': '-webkit-transform',\n  'MozTransform': '-moz-transform',\n  'msTransform': '-ms-transform',\n  'OTransform': '-o-transform'\n};\n\n// Get the correct transform key value, either plain 'transform' or a prefixed one.\nvar getTransformKey = function getTransformKey() {\n  if (!window.getComputedStyle) return null;\n\n  var el = document.createElement('div');\n  document.body.insertBefore(el, null);\n\n  for (var t in transformKeys) {\n    if (window.getComputedStyle(el)[t]) {\n      document.body.removeChild(el);\n      return t;\n    }\n  }\n\n  document.body.removeChild(el);\n  return null;\n};\n\n// Check if we have 3d support\nvar getHas3d = function getHas3d() {\n  if (!transformKey) return false; // No transform, no 3d. GET A NEW BROWSER YO\n\n  var el = document.createElement('div');\n  document.body.insertBefore(el, null);\n  el.style[transformKey] = 'translate3d(1px,1px,1px)';\n\n  var has3d = !!window.getComputedStyle(el).getPropertyValue(transformKey);\n  document.body.removeChild(el);\n\n  return has3d;\n};\n\n// Cache these values\nvar transformKey = getTransformKey();\nvar has3d = getHas3d();\n\nvar getInjectedTransformString = function getInjectedTransformString(node, prop, val) {\n\n  // If your browser doesn't support even prefixed transforms... get a new browser. Bye.\n  if (!transformKey) return;\n\n  // Get the node's previous transform value and store it.\n  var oldTransformString = node.style[transformKey] || '';\n\n  // set up variable declarations for 3d stuff\n  var transform3dString = void 0;\n  var axis = void 0;\n  var xyz = void 0;\n\n  // If we've got 3d, then USE IT! It's sooo much smoother. #blessed\n  if (has3d) {\n\n    // If it's a translate or scale, we can 3d-ify that. (I know there's some duplication but I'd rather be explicit here.)\n\n    // Axis is the index of the value we'll want to change (X is 0, Y is 1, Z is 3)\n    // Prop is the name of the property\n    // XYZ holds our actual values.\n    if (translations[prop] !== undefined) {\n      axis = translations[prop];\n      prop = 'translate3d';\n      xyz = ['0', '0', '0'];\n      if (val === null) val = 0;\n    } else if (scales[prop] !== undefined) {\n      axis = scales[prop];\n      prop = 'scale3d';\n      xyz = ['1', '1', '1'];\n      if (val === null) val = 1;\n    }\n\n    // If everything checks out, we should have our values set!\n    if (axis !== undefined) {\n      if (oldTransformString.indexOf(prop) > -1) {\n        var startOfString = oldTransformString.split(prop + '(')[0];\n        var extractedValue = oldTransformString.split(prop + '(')[1].split(')')[0];\n        xyz = extractedValue.split(',');\n      }\n\n      // Replace the value in the array, then join that sucker together.\n      xyz[axis] = val;\n      transform3dString = prop + '(' + xyz.join(',') + ')';\n    }\n  }\n\n  // Make a nice new string out of it with the scaled value.\n  var transformInjection = transform3dString || prop + '(' + val + ')';\n\n  var newTransformString = oldTransformString;\n\n  // Check if the new prop is already declared somehow in the old style value\n  var transformPropExists = oldTransformString.indexOf(prop) > -1;\n\n  // Because if it is, you don't want to add another copy.\n  if (transformPropExists) {\n    var _startOfString = oldTransformString.split(prop)[0];\n    var endOfString = oldTransformString.split(prop)[1].split(')')[1];\n    newTransformString = _startOfString + transformInjection + endOfString;\n  }\n  // In the same vein, if it isn't, you can't just replace the value because there might\n  // be some other transform properties hangin' out in there.\n  else newTransformString += ' ' + transformInjection;\n\n  return newTransformString;\n};\n\nmodule.exports = getInjectedTransformString;\n\n//# sourceURL=webpack://gulp-2022/./node_modules/choreographer-js/dist/getInjectedTransformString.js?");

/***/ }),

/***/ "./node_modules/choreographer-js/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/choreographer-js/dist/index.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar Choreographer = __webpack_require__(/*! ./Choreographer */ \"./node_modules/choreographer-js/dist/Choreographer.js\");\nmodule.exports = Choreographer;\n\nwindow.Choreographer = Choreographer;\n\n//# sourceURL=webpack://gulp-2022/./node_modules/choreographer-js/dist/index.js?");

/***/ }),

/***/ "./src/js/app.js":
/*!***********************!*\
  !*** ./src/js/app.js ***!
  \***********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _modules_functions_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modules/functions.js */ \"./src/js/modules/functions.js\");\n/* harmony import */ var _modules_choreorgapher_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modules/choreorgapher.js */ \"./src/js/modules/choreorgapher.js\");\n\n\n\n_modules_functions_js__WEBPACK_IMPORTED_MODULE_0__.isWebp()\n\n// console.log(choreographer);\n\n// window.addEventListener('scroll', () => {\n//   choreographer.runAnimationsAt(window.clientY)\n// })\n\nconst burger = document.querySelectorAll('.burger');\n\nburger.forEach (line => {  \n  line.addEventListener('click', (event) => {\n    line.classList.toggle(\"open\");\n  });\n});\n\nconsole.log(burger);\n\n\n\n//# sourceURL=webpack://gulp-2022/./src/js/app.js?");

/***/ }),

/***/ "./src/js/modules/choreorgapher.js":
/*!*****************************************!*\
  !*** ./src/js/modules/choreorgapher.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"choreographer\": () => (/* binding */ choreographer)\n/* harmony export */ });\n/* harmony import */ var choreographer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! choreographer-js */ \"./node_modules/choreographer-js/dist/index.js\");\n\n\nlet choreographer = new choreographer_js__WEBPACK_IMPORTED_MODULE_0__({\n  animations: [\n    {\n      range: [0, 1000],\n      selector: '#box',\n      type: 'scale',\n      style: 'opacity',\n      from: 0,\n      to: 1\n    }\n  ]\n})\n\n//# sourceURL=webpack://gulp-2022/./src/js/modules/choreorgapher.js?");

/***/ }),

/***/ "./src/js/modules/functions.js":
/*!*************************************!*\
  !*** ./src/js/modules/functions.js ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"isWebp\": () => (/* binding */ isWebp)\n/* harmony export */ });\nfunction isWebp() {\n  // Проверка поддержки webp\n  function testWebP(callback) {\n    let webP = new Image();\n    webP.onload = webP.onerror = function () {\n      callback(webP.height == 2);\n    };\n    webP.src = \"data:image/webp;base64,UklGRjoAAABXRUJQVlA4IC4AAACyAgCdASoCAAIALmk0mk0iIiIiIgBoSygABc6WWgAA/veff/0PP8bA//LwYAAA\";\n  }\n    \n    testWebP(function (support) {\n      let className = support === true ? 'webp' : 'no-webp';\n      document.documentElement.classList.add(className)\n  });\n}\n\n//# sourceURL=webpack://gulp-2022/./src/js/modules/functions.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/js/app.js");
/******/ 	
/******/ })()
;